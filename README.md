# Becoming a Software Engineer
To become a software engineer, you'll typically need to acquire a strong foundation in programming languages (e.g., Python, Java), data structures and algorithms, and software design patterns. You should also have a solid understanding of computer science concepts, such as object-oriented programming and software engineering principles. 

## Fundamentals
A foundation in mathematics and physics is essential for understanding computer science concepts.
This includes:
Basic algebra and calculus to develop problem-solving skills
Mathematical modeling to apply mathematical concepts to real-world problems
<!-- toc -->
- Math & Physics
    - A strong understanding of these subjects provides a solid basis for programming skills and software engineering principles.
- Data Structure & Algorithms
    - Understanding data structures (e.g., arrays, linked lists) and algorithms (e.g., sorting, searching).
    - Helps you design efficient programs that can solve real-world problems.
    - Familiarity with popular data structures and algorithms such as trees, graphs, and hash tables is also important.
- Programming Languages
    - Python:
        - A great language for beginners due to its simple syntax and extensive libraries.
        - Used in popular frameworks such as Django and Flask for web development.
    - Java:
        - A widely used language for Android app development, enterprise software, and web development.
        - Has a large community of developers and provides many resources for learning and troubleshooting.
    - C/C++:
        - These languages are often used for systems programming, embedded systems, and game development.
        - While less commonly used as a first language, they can still be useful for learning about operating system internals and low-level programming.
- UML (Unified Modeling Language):
    - A visual representation of software design patterns, including classes, objects, interfaces, and diagrams.
    - Helps you model and visualize the structure of complex systems.
- Source Control Tools (Git/Github):
    - Version control systems that allow you to track changes to your codebase over time.
    - Essential for maintaining a clean and collaborative development environment.
<!-- tocstop -->

## Computer Systems
The foundation of modern computing, including hardware and software components.
<!-- toc -->
- Operating System
    - An operating system manages computer hardware resources and provides a platform for running applications.
    - Examples: Windows, Linux, macOS
- Platform & Framework
    - A set of tools, libraries, or technologies that enable developers to build specific types of applications.
- Networks 
    - The physical and logical infrastructure that enables data communication between devices on the internet.
- Clouding computing
    - A remote computing environment that provides virtualized resources and services over the internet.
    - Examples: Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform (GCP)
    - Cloud Native Computing Foundation
        - https://landscape.cncf.io/?view-mode=grid
- Containers & Kubernetes
    - Containers provide a lightweight and portable way to deploy applications in a consistent manner across different environments.
        - https://8grams.medium.com/docker-revolutionizing-software-development-and-distribution-eddebd01b262
    - Kubernetes is an orchestration system that automates the deployment, scaling, and management of containers.
        - https://keetmalin.wixsite.com/keetmalin/post/understanding-container-orchestration-with-kubernetes
    - Benefits: improved deployment speed, reduced errors, and increased scalability

<!-- tocstop -->

## Software Development 
The process of creating, testing, and maintaining software systems.
<!-- toc -->
- Software Development Life Cycle (SDLC)
    - A structured approach to software development that involves several phases:
        1. Requirements Gathering
        2. Design
        3. Implementation
        4. Testing
        5. Deployment
- Object Oriented Analysis and Design (OOAD)
    - The process of analyzing and designing software systems using object-oriented principles.
- Architectures
    - A design approach for structuring software systems, which can include:
        1. Monolithic architecture
        2. Client/Server architecture
        3. WWW/N-Tier architecture        
        4. Service Oriented architecture
        5. Distibuted architecture                
        6. Microservices architecture
        7. Micro Frontend + Microservices architecture
            - https://semaphoreci.com/blog/microfrontends
            - https://blog.bitsrc.io/micro-frontend-architecture-a-guide-28f78ce825ad
        8. Serverless architecture
        9. Event Driven architecture
        10. Layered architecture
        11. Onion architecture
        12. Clean architecture
        13. Domain Driven architecture
            - https://medium.com/@lambrych/domain-driven-design-ddd-strategic-design-explained-55e10b7ecc0f
        14. Model Driven architecture
        15. Hexagonal (Port & adpater) architecture
        16. CQRS (Command Query Responsibility Segregation) architecture
        17. Plugin architecture
- Design Patterns (GoF)
    - Reusable solutions to common problems that have been observed in software development.
        - Creational Patterns
            1. Abstract Factory
            2. Builder
            3. Factory Method
            4. Prototype
            5. Singleton
        - Structural Patterns
            1. Adapter (Wrapper): Compatability - Open/Close Principles 
            2. Bridge
            3. Composite
            4. Decorator (Wrapper): Adding/changing behavior - Composition, Single Responsiblity, Open/Close Principles
                - https://daily.dev/blog/decorator-pattern-explained-basics-to-advanced
            5. Facade (Wrapper): Simplicity
            6. Flyweight
            7. Proxy
        - Behavioral Patterns
            1. Chanin of Responsibility
            2. Command
            3. Interpreter
            4. Iterator
            5. Mediator
            6. Memento
            7. Observer (Publish/Subscribe)
            8. State
            9. Strategy (Select an algorithm at runtime)
            10. Template Method
            11. Visitor
    - Anti-Patterns
        - https://bariscimen.medium.com/10-most-common-anti-patterns-every-software-engineer-must-avoid-182091438c2b
- System Design
    - The process of designing the overall structure and organization of a software system.
        - https://medium.com/bytebytego-system-design-alliance/system-design-blueprint-the-ultimate-guide-e27b914bf8f1
- Secure Coding
    - A set of practices for writing secure code, including:
        1. Input validation
        2. Error handling
- Concurrency
    - The ability of a program to perform multiple tasks concurrently, improving performance and responsiveness.
- Performance
    - Measures that are used to evaluate the efficiency and effectiveness of software systems.
    - Includes factors such as code complexity, data storage, and computational resources.
- Database
    - A database is a collection of organized data that can be accessed and manipulated by software applications.
- Testing & Debugging
    - The process of verifying that software systems meet the required specifications and are free from errors.
    - Includes testing for functionality, performance, security, and reliability
- DevSecOps (Development Security Operations)
    - DevSecOps refers to the practice of integrating security into the software development lifecycle from the earliest stages of development, through testing and deployment, all the way to maintenance and operation.
<!-- tocstop -->

## Specific Fields in Software Engineering
<!-- toc -->
- Artificial Intelligence
    - A broad field that encompasses the development of intelligent machines that can think and act like humans.
- Data Science
    - The application of data analysis and modeling techniques to extract insights and knowledge from data.
        - https://www.comet.com/site/blog/data-fabric-data-mesh-two-approaches-one-data-driven-destiny/
    - Web scraping
        - https://www.youtube.com/playlist?list=PLRzwgpycm-Fjvdf7RpmxnPMyJ80RecJjv
    - Airflow
        - https://www.youtube.com/watch?v=3xyoM28B40Y
    - AmazonEMR
        - https://www.youtube.com/watch?v=8bOgOvz6Tcg
    - Kafka
        - https://www.youtube.com/watch?v=D2NYvGlbK0M
        - https://www.youtube.com/watch?v=SG06Pj5ZZ7g
    - Hadoop Vs Spark
        - https://www.netsolutions.com/insights/hadoop-vs-spark
        - https://www.ibm.com/think/insights/hadoop-vs-spark
        - https://jelvix.com/blog/hadoop-vs-spark-what-to-choose-to-process-big-data
        - https://logz.io/blog/hadoop-vs-spark/
    - Spark
        - https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html
    - Databricks
        - https://www.youtube.com/@Databricks
        - https://www.databricks.com/kr/glossary/what-is-spark-streaming
        - https://docs.databricks.com/en/data-engineering.html
        - https://www.databricks.com/blog/2020/06/18/introducing-apache-spark-3-0-now-available-in-databricks-runtime-7-0.html
    - Snowfake
        - https://www.youtube.com/@snowflakedevelopers
    - AWS
        - https://www.youtube.com/watch?v=tykcCf-Zz1M
- Graphics
    - A domain that involves creating visual representations of information using various techniques, such as 2D and 3D graphics, animation, and rendering.
- Game
    - A field that requires the development of games, including game design, programming, and testing.
- IoT (Internet of Things)
    - The network of physical devices, vehicles, home appliances, and other items embedded with sensors, software, and connectivity, allowing them to collect and exchange data.
- Robotics
    - A field that involves the design, construction, operation, and control of robots, often for applications such as manufacturing, healthcare, and transportation.
- Embedded Systems
    - A field that involves the design, construction, operation, and control of robots, often for applications such as manufacturing, healthcare, and transportation.
<!-- tocstop -->

## Professionalism
As a software programmer, professionalism is essential to succeed in your career.
<!-- toc -->
- Code quality and organization
- Communication skills
- Collaboration and teamwork
- Continuously learning and improving
- Code reviews
- Time management and prioritization
<!-- tocstop -->
